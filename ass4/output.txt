Mon Nov 22 11:00:26 PM PST 2021
Linux x1 5.13.0-21-generic #21-Ubuntu SMP Tue Oct 19 08:59:28 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),133(lxd),134(sambashare)
=====================================================
1. Compiles without warnings with -Wall -Wextra flags
=====================================================
=====================================================
2. Runs and produces correct output
=====================================================
Level: 2 -- -2147483648, -7, 1, 20, 2147483647, 
Level: 1 -- -2147483648, -7, 0, 1, 20, 2147483647, 
Level: 0 -- -2147483648, -7, -1, 0, 1, 3, 20, 421472193, 2147483647, 

Level: 4 -- -2147483648, 9, 2147483647, 
Level: 3 -- -2147483648, 9, 2147483647, 
Level: 2 -- -2147483648, 5, 9, 2147483647, 
Level: 1 -- -2147483648, 3, 5, 7, 9, 2147483647, 
Level: 0 -- -2147483648, 1, 3, 5, 7, 9, 2147483647, 

7 ? true
3 ? true
-100 ? false
100 ? false
Level: 4 -- -2147483648, 9, 2147483647, 
Level: 3 -- -2147483648, 9, 2147483647, 
Level: 2 -- -2147483648, 9, 2147483647, 
Level: 1 -- -2147483648, 3, 7, 9, 2147483647, 
Level: 0 -- -2147483648, 1, 3, 7, 9, 2147483647, 

Done.
=====================================================
3. clang-tidy warnings are fixed
=====================================================
=====================================================
4. clang-format does not find any formatting issues
=====================================================
Running clang-format on ./main.cpp
Running clang-format on ./skiplist.cpp
=====================================================
5. No memory leaks using g++
=====================================================
=====================================================
6. No memory leaks using valgrind, look for "definitely lost" 
=====================================================
==31119== Memcheck, a memory error detector
==31119== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==31119== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info
==31119== Command: ./a.out
==31119== Parent PID: 31031
==31119== 
==31119== Conditional jump or move depends on uninitialised value(s)
==31119==    at 0x10C3AA: SkipList::containsSNode(int) const (skiplist.cpp:267)
==31119==    by 0x10C3F1: SkipList::contains(int) const (skiplist.cpp:286)
==31119==    by 0x10A5F2: test0() (main.cpp:18)
==31119==    by 0x10AE8A: main (main.cpp:57)
==31119== 
==31119== Conditional jump or move depends on uninitialised value(s)
==31119==    at 0x10BCEF: operator<<(std::ostream&, SkipList const&) (skiplist.cpp:72)
==31119==    by 0x10A7EC: test0() (main.cpp:23)
==31119==    by 0x10AE8A: main (main.cpp:57)
==31119== 
==31119== Conditional jump or move depends on uninitialised value(s)
==31119==    at 0x10C3AA: SkipList::containsSNode(int) const (skiplist.cpp:267)
==31119==    by 0x10C3F1: SkipList::contains(int) const (skiplist.cpp:286)
==31119==    by 0x10A825: test0() (main.cpp:24)
==31119==    by 0x10AE8A: main (main.cpp:57)
==31119== 
==31119== Conditional jump or move depends on uninitialised value(s)
==31119==    at 0x10BB75: SkipList::deleteLevels() (skiplist.cpp:47)
==31119==    by 0x10BA6B: SkipList::~SkipList() (skiplist.cpp:34)
==31119==    by 0x10A860: test0() (main.cpp:24)
==31119==    by 0x10AE8A: main (main.cpp:57)
==31119== 
==31119== Conditional jump or move depends on uninitialised value(s)
==31119==    at 0x10C232: SkipList::remove(int) (skiplist.cpp:181)
==31119==    by 0x10A874: test0() (main.cpp:26)
==31119==    by 0x10AE8A: main (main.cpp:57)
==31119== 
==31119== Conditional jump or move depends on uninitialised value(s)
==31119==    at 0x10C3AA: SkipList::containsSNode(int) const (skiplist.cpp:267)
==31119==    by 0x10C19B: SkipList::remove(int) (skiplist.cpp:174)
==31119==    by 0x10A8B4: test0() (main.cpp:27)
==31119==    by 0x10AE8A: main (main.cpp:57)
==31119== 
==31119== Conditional jump or move depends on uninitialised value(s)
==31119==    at 0x10BB75: SkipList::deleteLevels() (skiplist.cpp:47)
==31119==    by 0x10BA6B: SkipList::~SkipList() (skiplist.cpp:34)
==31119==    by 0x10A932: test0() (main.cpp:29)
==31119==    by 0x10AE8A: main (main.cpp:57)
==31119== 
==31119== Conditional jump or move depends on uninitialised value(s)
==31119==    at 0x10BCEF: operator<<(std::ostream&, SkipList const&) (skiplist.cpp:72)
==31119==    by 0x10ABCB: test1() (main.cpp:42)
==31119==    by 0x10AE8F: main (main.cpp:58)
==31119== 
==31119== Conditional jump or move depends on uninitialised value(s)
==31119==    at 0x10C3AA: SkipList::containsSNode(int) const (skiplist.cpp:267)
==31119==    by 0x10C3F1: SkipList::contains(int) const (skiplist.cpp:286)
==31119==    by 0x10ACA2: test1() (main.cpp:45)
==31119==    by 0x10AE8F: main (main.cpp:58)
==31119== 
==31119== Conditional jump or move depends on uninitialised value(s)
==31119==    at 0x10C3AA: SkipList::containsSNode(int) const (skiplist.cpp:267)
==31119==    by 0x10C3F1: SkipList::contains(int) const (skiplist.cpp:286)
==31119==    by 0x10ACEE: test1() (main.cpp:46)
==31119==    by 0x10AE8F: main (main.cpp:58)
==31119== 
==31119== Conditional jump or move depends on uninitialised value(s)
==31119==    at 0x10C232: SkipList::remove(int) (skiplist.cpp:181)
==31119==    by 0x10AD1E: test1() (main.cpp:48)
==31119==    by 0x10AE8F: main (main.cpp:58)
==31119== 
==31119== Conditional jump or move depends on uninitialised value(s)
==31119==    at 0x10C3AA: SkipList::containsSNode(int) const (skiplist.cpp:267)
==31119==    by 0x10C19B: SkipList::remove(int) (skiplist.cpp:174)
==31119==    by 0x10AD66: test1() (main.cpp:50)
==31119==    by 0x10AE8F: main (main.cpp:58)
==31119== 
==31119== Conditional jump or move depends on uninitialised value(s)
==31119==    at 0x10BCEF: operator<<(std::ostream&, SkipList const&) (skiplist.cpp:72)
==31119==    by 0x10ADB8: test1() (main.cpp:52)
==31119==    by 0x10AE8F: main (main.cpp:58)
==31119== 
==31119== Conditional jump or move depends on uninitialised value(s)
==31119==    at 0x10BB75: SkipList::deleteLevels() (skiplist.cpp:47)
==31119==    by 0x10BA6B: SkipList::~SkipList() (skiplist.cpp:34)
==31119==    by 0x10ADD6: test1() (main.cpp:53)
==31119==    by 0x10AE8F: main (main.cpp:58)
==31119== 
==31119== 
==31119== HEAP SUMMARY:
==31119==     in use at exit: 0 bytes in 0 blocks
==31119==   total heap usage: 66 allocs, 66 frees, 79,148 bytes allocated
==31119== 
==31119== All heap blocks were freed -- no leaks are possible
==31119== 
==31119== Use --track-origins=yes to see where uninitialised values come from
==31119== For lists of detected and suppressed errors, rerun with: -s
==31119== ERROR SUMMARY: 30 errors from 14 contexts (suppressed: 0 from 0)
=====================================================
7. Tests have full code coverage
=====================================================
File '/home/user/Filen Sync/Documents/College/Classwork/CSS342/ass4/main.cpp':
Name                        Regions    Miss   Cover     Lines    Miss   Cover  Branches    Miss   Cover
-------------------------------------------------------------------------------------------------------
test0()                           1       0 100.00%        17       9  47.06%         0       0   0.00%
test1()                           1       0 100.00%        19       3  84.21%         0       0   0.00%
main                              1       0 100.00%         6       0 100.00%         0       0   0.00%
-------------------------------------------------------------------------------------------------------
TOTAL                             3       0 100.00%        42      12  71.43%         0       0   0.00%

File '/home/user/Filen Sync/Documents/College/Classwork/CSS342/ass4/skiplist.cpp':
Name                                                           Regions    Miss   Cover     Lines    Miss   Cover  Branches    Miss   Cover
------------------------------------------------------------------------------------------------------------------------------------------
SNode::SNode(int)                                                    1       0 100.00%         1       0 100.00%         0       0   0.00%
SkipList::SkipList(int, int)                                         1       0 100.00%         4       1  75.00%         0       0   0.00%
SkipList::~SkipList()                                                1       0 100.00%         5       0 100.00%         0       0   0.00%
SkipList::deleteLevels()                                             6       0 100.00%        17       0 100.00%         4       0 100.00%
operator<<(std::ostream&, SkipList const&)                           6       0 100.00%        14       0 100.00%         4       0 100.00%
SkipList::makeLevels()                                               4       0 100.00%        15       0 100.00%         2       0 100.00%
SkipList::add(int)                                                  14       0 100.00%        29       0 100.00%        10       0 100.00%
SkipList::add(std::vector<int, std::allocator<int> > const&)         6       0 100.00%        11       0 100.00%         4       0 100.00%
SkipList::remove(int)                                                6       0 100.00%        20       0 100.00%         4       0 100.00%
SkipList::addBefore(SNode*, SNode*)                                  1       0 100.00%         6       0 100.00%         0       0   0.00%
SkipList::connectTwoHorizontally(SNode*, SNode*)                     1       0 100.00%         4       0 100.00%         0       0   0.00%
SkipList::connectTwoVertically(SNode*, SNode*)                       1       0 100.00%         4       0 100.00%         0       0   0.00%
SkipList::shouldInsertAtHigher() const                               1       0 100.00%         3       0 100.00%         0       0   0.00%
SkipList::containsSNode(int) const                                  12       0 100.00%        28       0 100.00%         8       0 100.00%
SkipList::contains(int) const                                        1       0 100.00%         3       0 100.00%         0       0   0.00%
------------------------------------------------------------------------------------------------------------------------------------------
TOTAL                                                               62       0 100.00%       164       1  99.39%        36       0 100.00%
/home/user/Filen Sync/Documents/College/Classwork/CSS342/ass4/main.cpp:
    1|       |#include <cassert>
    2|       |#include <iostream>
    3|       |
    4|       |#include "skiplist.h"
    5|       |
    6|       |using namespace std;
    7|       |
    8|       |void test0()
    9|      1|{
   10|      1|   srand(time(0)); // seed for generating random numbers
   11|       |
   12|      1|   SkipList s1(3, 60);
   13|       |   // cout << s1 << endl;
   14|      1|   s1.add(3);
   15|      1|   s1.add(20);
   16|      1|   assert(s1.contains(3));
   17|      0|   assert(s1.contains(20));
   18|      0|   assert(!s1.contains(-14));
   19|      0|   assert(!s1.add(3));
   20|      0|   assert(s1.add(vector<int>{1, -7, 0}));
   21|      0|   assert(!s1.add(vector<int>{-1, 421472193, -1}));
   22|       |
   23|      0|   cout << s1 << endl;
   24|      1|   assert(!SkipList(1, 99).contains(0));
   25|       |
   26|      0|   assert(s1.remove(3));
   27|      0|   assert(!s1.remove(202020));
   28|      0|   assert(s1.add(1478));
   29|      1|}
   30|       |
   31|       |void test1()
   32|      1|{
   33|       |   // setting seed for easy testing
   34|      1|   srand(10000);
   35|      1|   SkipList skp(5, 80);
   36|      1|   cout << boolalpha;
   37|      1|   skp.add(3);
   38|      1|   skp.add(5);
   39|      1|   skp.add(vector<int>{1, 7, 9});
   40|       |   // cannot add existing
   41|      1|   assert(!skp.add(vector<int>{1, 7}));
   42|      0|   cout << skp << endl;
   43|      1|   cout << "7 ? " << skp.contains(7) << endl;
   44|      1|   cout << "3 ? " << skp.contains(3) << endl;
   45|      1|   cout << "-100 ? " << skp.contains(-100) << endl;
   46|      1|   cout << "100 ? " << skp.contains(100) << endl;
   47|       |
   48|      1|   bool result = skp.remove(5);
   49|      1|   assert(result);
   50|      0|   result = skp.remove(5);
   51|      1|   assert(!result);
   52|      0|   cout << skp << endl;
   53|      1|}
   54|       |
   55|       |int main()
   56|      1|{
   57|      1|   test0();
   58|      1|   test1();
   59|       |
   60|      1|   cout << "Done." << endl;
   61|      1|   return 0;
   62|      1|}

/home/user/Filen Sync/Documents/College/Classwork/CSS342/ass4/skiplist.cpp:
    1|       |
    2|       |// modified by mashhadi on 14th feb to add an alternative op<<
    3|       |// Modified by Egor Kolyshkin on 11/12/21.
    4|       |
    5|       |#include <cassert>
    6|       |#include <climits>
    7|       |#include <cstdlib>
    8|       |#include <iostream>
    9|       |
   10|       |#include "skiplist.h"
   11|       |
   12|       |using namespace std;
   13|       |
   14|       |// SNODE
   15|       |
   16|       |// constructor that sets node value
   17|     54|SNode::SNode(int value) : value{value} {}
   18|       |
   19|       |// SKIPLIST
   20|       |
   21|       |// constructor that sets max level of list and probability of inserting at
   22|       |// higher level
   23|       |SkipList::SkipList(int maxLevel, int probability)
   24|       |    : maxLevel{maxLevel}, probability{probability}
   25|      3|{
   26|       |   // checks preconditions
   27|      3|   assert(maxLevel > 0 && probability >= 0 && probability < 100);
   28|      0|   makeLevels();
   29|      3|}
   30|       |
   31|       |// destructor
   32|       |SkipList::~SkipList()
   33|      3|{
   34|      3|   deleteLevels();
   35|      3|   delete[] FrontGuards;
   36|      3|   delete[] RearGuards;
   37|      3|}
   38|       |
   39|       |// deletes all levels of skiplist
   40|       |void SkipList::deleteLevels()
   41|      3|{
   42|       |   // for each level starting from the top
   43|     12|   for (int i = maxLevel - 1; i >= 0; i--)
   44|      9|   {
   45|      9|      SNode *curPtr = FrontGuards[i];
   46|       |
   47|     54|      while (curPtr != nullptr)
   48|     45|      {
   49|     45|         SNode *delPtr = curPtr;
   50|     45|         curPtr = curPtr->forward;
   51|       |
   52|     45|         delPtr->up = nullptr;
   53|     45|         delPtr->down = nullptr;
   54|     45|         delPtr->backward = nullptr;
   55|     45|         delPtr->forward = nullptr;
   56|     45|         delete delPtr;
   57|     45|         delPtr = nullptr;
   58|     45|      }
   59|      9|   }
   60|      3|}
   61|       |
   62|       |// MUTATORS
   63|       |
   64|       |// prints all levels of skiplist including guard node values
   65|       |ostream &operator<<(ostream &Out, const SkipList &SkipL)
   66|      3|{
   67|     16|   for (int Index = SkipL.maxLevel - 1; Index >= 0; Index--)
   68|     13|   {
   69|     13|      Out << "Level: " + to_string(Index) + " -- ";
   70|     13|      SNode *Curr = SkipL.FrontGuards[Index];
   71|       |
   72|     78|      while (Curr != nullptr)
   73|     65|      {
   74|     65|         Out << to_string(Curr->value) + ", ";
   75|     65|         Curr = Curr->forward;
   76|     65|      }
   77|       |
   78|     13|      Out << "\n";
   79|     13|   }
   80|       |
   81|      3|   return Out;
   82|      3|}
   83|       |
   84|       |// creates all levels of skiplist
   85|       |void SkipList::makeLevels()
   86|      3|{
   87|       |   // create first level guard nodes and link them together
   88|      3|   FrontGuards = new SNode *[maxLevel];
   89|      3|   RearGuards = new SNode *[maxLevel];
   90|      3|   FrontGuards[0] = new SNode(INT_MIN);
   91|      3|   RearGuards[0] = new SNode(INT_MAX);
   92|      3|   connectTwoHorizontally(FrontGuards[0], RearGuards[0]);
   93|       |
   94|       |   // create higher levels
   95|      9|   for (int level = 1; level < maxLevel; level++)
   96|      6|   {
   97|       |      // create guard nodes and link them together
   98|      6|      FrontGuards[level] = new SNode(INT_MIN);
   99|      6|      RearGuards[level] = new SNode(INT_MAX);
  100|      6|      connectTwoHorizontally(FrontGuards[level], RearGuards[level]);
  101|       |
  102|       |      // link previous level to current level
  103|      6|      connectTwoVertically(FrontGuards[level - 1], FrontGuards[level]);
  104|      6|      connectTwoVertically(RearGuards[level - 1], RearGuards[level]);
  105|      6|   }
  106|      3|}
  107|       |
  108|       |// adds an int value to list
  109|       |// returns true if successful
  110|       |// false otherwise
  111|       |bool SkipList::add(int value)
  112|     17|{
  113|     17|   int level = 0;
  114|     17|   SNode *prevNode; // previously inserted node to connect up and down to
  115|       |
  116|     17|   do
  117|     36|   {
  118|     36|      SNode *newNode = new SNode(value);
  119|     36|      SNode *curPtr = FrontGuards[level];
  120|       |
  121|       |      // find first value larger or equal to insert
  122|     84|      while (value > curPtr->forward->value)
  123|     48|      {
  124|     48|         curPtr = curPtr->forward;
  125|     48|      }
  126|       |      // if contains value
  127|     36|      if (curPtr->forward->value == value)
  128|      4|      { // dont add
  129|      4|         delete newNode;
  130|      4|         return false;
  131|      4|      }
  132|     32|      else
  133|     32|      { // add value before next larger value
  134|     32|         addBefore(newNode, curPtr->forward);
  135|     32|      }
  136|       |
  137|       |      // connect previous node to current up and down
  138|     32|      if (level > 0)
  139|     19|      {
  140|     19|         connectTwoVertically(prevNode, newNode);
  141|     19|      }
  142|       |
  143|     32|      level++;
  144|     32|      prevNode = newNode;
  145|     32|   } while (level < maxLevel && shouldInsertAtHigher());
  146|       |
  147|     13|   return true;
  148|     17|}
  149|       |
  150|       |// adds a vector of values to list
  151|       |// returns true if ALL items from vector were added
  152|       |// false otherwise
  153|       |bool SkipList::add(const vector<int> &values)
  154|      4|{
  155|      4|   bool noDups = true;
  156|       |
  157|       |   // parses each vector value and adds it individually
  158|     15|   for (int i = 0; i < values.size(); i++)
  159|     11|   {
  160|     11|      if (!add(values[i]))
  161|      3|      { // found a duplicate
  162|      3|         noDups = false;
  163|      3|      }
  164|     11|   }
  165|       |
  166|      4|   return noDups;
  167|      4|}
  168|       |
  169|       |// removes an int value from list
  170|       |// returns true if successful
  171|       |// false otherwise
  172|       |bool SkipList::remove(int value)
  173|      4|{
  174|      4|   SNode *curNode = containsSNode(value); // will always be topmost node
  175|       |
  176|      4|   if (curNode == nullptr)
  177|      2|   {
  178|      2|      return false; // nothing to remove
  179|      2|   }
  180|       |
  181|      7|   while (curNode != nullptr)
  182|      5|   {
  183|       |      // connect horizontally left and right nodes
  184|      5|      connectTwoHorizontally(curNode->backward, curNode->forward);
  185|       |
  186|       |      // remove horizontal pointers
  187|      5|      curNode->backward = nullptr;
  188|      5|      curNode->forward = nullptr;
  189|       |
  190|       |      // previous node to delete
  191|      5|      SNode *delNode = curNode;
  192|       |
  193|       |      // move to next level
  194|      5|      curNode = curNode->down;
  195|       |
  196|       |      // delete previous node
  197|      5|      delNode->up = nullptr;
  198|      5|      delNode->down = nullptr;
  199|      5|      delete delNode;
  200|      5|      delNode = nullptr;
  201|      5|   }
  202|       |
  203|      2|   return true;
  204|      4|}
  205|       |
  206|       |// Given a SNode, place it before the given NextNode
  207|       |void SkipList::addBefore(SNode *NewNode, SNode *NextNode)
  208|     32|{
  209|       |   // Link next to node in front
  210|     32|   NewNode->forward = NextNode;
  211|       |   // Link prev to node behind
  212|     32|   NewNode->backward = NextNode->backward;
  213|       |   // Link node in back to new node
  214|     32|   NextNode->backward->forward = NewNode;
  215|       |   // Link node in front to new node
  216|     32|   NextNode->backward = NewNode;
  217|     32|}
  218|       |
  219|       |// private method to connect 2 nodes forward and backward
  220|       |void SkipList::connectTwoHorizontally(SNode *left, SNode *right)
  221|     14|{
  222|     14|   left->forward = right;
  223|     14|   right->backward = left;
  224|     14|}
  225|       |
  226|       |// private method to connect 2 nodes up and down
  227|       |void SkipList::connectTwoVertically(SNode *lower, SNode *higher)
  228|     31|{
  229|     31|   lower->up = higher;
  230|     31|   higher->down = lower;
  231|     31|}
  232|       |
  233|       |// checks if node should be inserted at higher level
  234|       |// returns true if it should be inserted
  235|       |// false otherwise
  236|       |bool SkipList::shouldInsertAtHigher() const
  237|     27|{
  238|     27|   return (rand() % 100) < probability;
  239|     27|}
  240|       |
  241|       |// Checks to see whether or not a data value exists in the list
  242|       |// Returns the NODE if the value exists in the SkipList.
  243|       |// Returns nullptr otherwise
  244|       |SNode *SkipList::containsSNode(int value) const
  245|     12|{
  246|     12|   SNode *foundNode = nullptr;
  247|     12|   int level = maxLevel - 1;
  248|       |
  249|       |   // search for value starting from top layer
  250|     12|   SNode *curPtr = FrontGuards[level];
  251|       |
  252|     45|   while (foundNode == nullptr)
  253|     39|   {
  254|       |      // find first value larger than insert
  255|     48|      while (curPtr->forward->value < value)
  256|      9|      {
  257|      9|         curPtr = curPtr->forward;
  258|      9|      }
  259|       |      // if value is found
  260|     39|      if (curPtr->forward->value == value)
  261|      6|      {
  262|      6|         foundNode = curPtr->forward;
  263|      6|      }
  264|       |      // go down a level and keep searching
  265|     33|      else
  266|     33|      { // if not at the bottom yet
  267|     33|         if (curPtr->down != nullptr)
  268|     27|         { // move down
  269|     27|            curPtr = curPtr->down;
  270|     27|         }
  271|      6|         else
  272|      6|         {
  273|      6|            return nullptr;
  274|      6|         }
  275|     33|      }
  276|     39|   }
  277|       |
  278|      6|   return foundNode;
  279|     12|}
  280|       |
  281|       |// Checks to see whether or not a data value exists in the list
  282|       |// Returns true if the value exists in the SkipList.
  283|       |// Returns false otherwise
  284|       |bool SkipList::contains(int value) const
  285|      8|{
  286|      8|   return (containsSNode(value) != nullptr);
  287|      8|}

Mon Nov 22 11:00:37 PM PST 2021
=====================================================
To create an output.txt file with all the output from this script
Run the below command
      ./create-output.sh > output.txt 2>&1 
=====================================================
